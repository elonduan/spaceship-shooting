<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ball Shooter — Smooth Turning & Banking2 (fixed)</title>
  <style>
    html,body{height:100%;margin:0;background:#000;color:#ddd;font-family:system-ui,-apple-system,Segoe UI,Roboto;overflow:hidden}
    #overlay{position:fixed;left:12px;top:12px;z-index:10;max-width:420px}
    .panel{background:rgba(0,0,0,0.45);padding:12px;border-radius:8px;backdrop-filter:blur(4px)}
    #win,#lose{display:none;padding:18px;margin-top:12px;border-radius:8px;font-weight:700}
    #win{background:linear-gradient(90deg,#0f0,#005500);color:#001}
    #lose{background:linear-gradient(90deg,#f00,#550000);color:#fff}
    #canvas-container{width:100%;height:100vh;display:block}
    input[type=range]{width:100%}
    label{font-size:13px;display:block;margin-top:10px}
    #crosshair{position:fixed;left:50%;top:50%;width:20px;height:20px;margin-left:-10px;margin-top:-10px;z-index:5;pointer-events:none}
    #crosshair:before,#crosshair:after{content:"";position:absolute;background:#fff}
    #crosshair:before{left:9px;top:0;width:2px;height:20px}
    #crosshair:after{left:0;top:9px;width:20px;height:2px}
    #joystick { position:fixed; bottom:80px; left:80px; width:120px; height:120px; background:rgba(255,255,255,0.1); border-radius:50%; touch-action:none; z-index:20;}
    #stick { position:absolute; left:50%; top:50%; width:50px; height:50px; margin-left:-25px; margin-top:-25px; background:rgba(255,255,255,0.3); border-radius:50%;}
    #buttons { position:fixed; bottom:80px; right:80px; display:flex; flex-direction:column; gap:12px; z-index:20;}
    #buttons button { width:70px; height:70px; border-radius:50%; border:none; background:rgba(255,255,255,0.2); color:#fff; font-size:18px;}
    #buttons button.active { box-shadow:0 0 18px rgba(255,255,255,0.15); background:rgba(255,255,255,0.28); }
    #hud { position:fixed; top:10px; left:0; right:0; display:flex; justify-content:space-between; padding:0 20px; z-index:15; align-items:center; gap:12px; }
    .barContainer { width:180px; height:20px; background:rgba(255,255,255,0.12); border:1px solid #888; border-radius:10px; overflow:hidden; display:flex; align-items:center;}
    .barSegments { display:flex; height:100%; width:100%; }
    .hp { height:100%; transition: width 120ms linear; flex: 0 0 auto; }
    .red   { background:#ff2b2b; width:33.3333%; }
    .white { background:#ffffff; width:33.3333%; }
    .green { background:#2ecc40; width:33.3333%; }
    #missileUI{position:fixed; left:50%; top: calc(50% + 24px); transform:translateX(-50%); font-size:13px; color:#fff; z-index:20; text-align:center; padding:6px 10px; background:rgba(0,0,0,0.35); border-radius:8px; pointer-events:none;}
    #arrowIndicator {
      position: fixed;
      width: 0;
      height: 0;
      border-left: 12px solid transparent;
      border-right: 12px solid transparent;
      border-bottom: 20px solid yellow;
      z-index: 50;
      transform-origin: center;
      pointer-events: none;
      display: none;
    }
    /* defeated counter style */
    #defeatedCounter { margin-top:8px; font-weight:700; font-size:13px; color:#fff;}
  </style>
</head>
<body>
  <div id="overlay">
    <div class="panel">
      <div><strong>Ball Shooter Competition — Smooth Turning - 1.5</strong></div>
      <ul style="margin:8px 0 0 18px;font-size:13px">
        <li>Arrow keys / Joystick: pitch & yaw</li>
        <li>A / D buttons: roll</li>
        <li>Shoot button / Space: fire</li>
        <li>M: launch missile (4 per game)</li>
        <li>R: reset</li>
        <li>G: steer ship toward crosshair (hold)</li>
        <li>world record: 3</li>
      </ul>
      <label for="sensitivity">Rotation sensitivity</label>
      <input id="sensitivity" type="range" min="0.005" max="0.05" step="0.002" value="0.015">
      <button id="resetBtn">Reset</button>
      <div style="margin-top:8px">Missiles left: <span id="missileCount">4</span></div>
      <div id="defeatedCounter">Defeated ships: <span id="defeatedCount">0</span></div>
      <div id="win">You destroyed the spaceship — you win! </div>
      <div id="lose">The spaceship destroyed you! </div>
    </div>
  </div>

  <div class="hud-row" id="hud">
    <div class="barContainer">
      <div id="playerBar" class="barSegments">
        <div class="hp red"></div>
        <div class="hp white"></div>
        <div class="hp green"></div>
      </div>
    </div>

    <div class="barContainer">
      <div id="enemyBar" class="barSegments">
        <div class="hp red"></div>
        <div class="hp white"></div>
        <div class="hp green"></div>
      </div>
    </div>

    
  </div>

  <div id="crosshair"></div>
  <div id="missileUI"><span id="missileCountUI"></span></div>
  <div id="canvas-container"></div>
  <div id="arrowIndicator"></div>
  <div id="joystick"><div id="stick"></div></div>
  <div id="buttons">
    <button id="shootBtn">Shoot</button>
    <button id="rollLeft">A</button>
    <button id="rollRight">D</button>
    <button id="missileBtn">M</button>
    <button id="autoShootBtn">Auto</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/loaders/STLLoader.js"></script>
  <script>
    /*********************** Basic scene & helpers *************************/
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 5000);
    camera.position.set(0,0,0);

    // Create simple starfield (points)
    function createStars(){
      const starCount = 3000;
      const geom = new THREE.BufferGeometry();
      const positions = new Float32Array(starCount*3);
      for(let i=0;i<starCount;i++){
        positions[i*3+0] = (Math.random()-0.5)*4000;
        positions[i*3+1] = (Math.random()-0.5)*4000;
        positions[i*3+2] = (Math.random()-0.5)*4000;
      }
      geom.setAttribute('position', new THREE.BufferAttribute(positions,3));
      const mat = new THREE.PointsMaterial({color:0xffffff,size:1.5,sizeAttenuation:true});
      return new THREE.Points(geom,mat);
    }
    scene.add(createStars());

    // (star creation code omitted in this summary - it's identical to your original, kept below)
    function makeRadialTextureStar(size = 256) {
      const c = document.createElement('canvas');
      c.width = c.height = size;
      const ctx = c.getContext('2d');
      const cx = size/2, cy = size/2, r = size/2;
      const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
      g.addColorStop(0.0, 'rgba(255,255,255,1)');
      g.addColorStop(0.06, 'rgba(255,255,255,1)');
      g.addColorStop(0.12, 'rgba(220,235,255,0.95)');
      g.addColorStop(0.25, 'rgba(160,200,255,0.65)');
      g.addColorStop(0.5, 'rgba(80,120,180,0.18)');
      g.addColorStop(1.0, 'rgba(0,0,0,0)');
      ctx.fillStyle = g;
      ctx.fillRect(0,0,size,size);
      const tex = new THREE.CanvasTexture(c);
      tex.needsUpdate = true;
      return tex;
    }

    function makeElongatedFlareTexture(length = 1024, height = 32, color = 'rgba(200,230,255,1)') {
      const c = document.createElement('canvas');
      c.width = Math.max(256, Math.round(length));
      c.height = Math.max(8, Math.round(height));
      const ctx = c.getContext('2d');
      const w = c.width, h = c.height;
      const band = ctx.createLinearGradient(0, 0, w, 0);
      const col = color;
      band.addColorStop(0, 'rgba(255,255,255,0)');
      band.addColorStop(0.12, col.replace(/,1\)$/, ',0.95)'));
      band.addColorStop(0.5, col.replace(/,1\)$/, ',0.98)'));
      band.addColorStop(0.88, col.replace(/,1\)$/, ',0.95)'));
      band.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = band;
      ctx.fillRect(0, (h*0.5) - (h*0.35), w, h*0.7);
      const featherRadius = Math.min(w * 0.12, 200);
      const lgL = ctx.createRadialGradient(0, h/2, 0, 0, h/2, featherRadius);
      lgL.addColorStop(0, col.replace(/,1\)$/, ',0.95)'));
      lgL.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = lgL;
      ctx.fillRect(-featherRadius, 0, featherRadius, h);
      const lgR = ctx.createRadialGradient(w, h/2, 0, w, h/2, featherRadius);
      lgR.addColorStop(0, col.replace(/,1\)$/, ',0.95)'));
      lgR.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = lgR;
      ctx.fillRect(w, 0, featherRadius, h);
      const tex = new THREE.CanvasTexture(c);
      tex.needsUpdate = true;
      return tex;
    }

    const brightStars = [];
    function createBrightStar(position, scale = 400) {
      const innerCoreTex = makeRadialTextureStar(128);
      const innerCoreMat = new THREE.SpriteMaterial({
        map: innerCoreTex, transparent: true,
        blending: THREE.AdditiveBlending, depthWrite: false
      });
      const innerCore = new THREE.Sprite(innerCoreMat);
      innerCore.position.copy(position);
      innerCore.scale.set(scale * 0.06, scale * 0.06, 1);
      scene.add(innerCore);

      const coreTex = makeRadialTextureStar(256);
      const coreMat = new THREE.SpriteMaterial({
        map: coreTex, transparent: true,
        blending: THREE.AdditiveBlending, depthWrite: false
      });
      const core = new THREE.Sprite(coreMat);
      core.position.copy(position);
      core.scale.set(scale * 0.12, scale * 0.12, 1);
      scene.add(core);

      const haloTex = makeRadialTextureStar(512);
      const haloMat = new THREE.SpriteMaterial({
        map: haloTex, transparent: true,
        blending: THREE.AdditiveBlending, depthWrite: false
      });
      const halo = new THREE.Sprite(haloMat);
      halo.position.copy(position);
      halo.scale.set(scale * 0.9, scale * 0.56, 1);
      scene.add(halo);

      const flareTex = makeElongatedFlareTexture(Math.round(scale * 2.4), Math.max(4, Math.round(scale * 0.02)), 'rgba(200,230,255,1)');
      const flareMat = new THREE.SpriteMaterial({ map: flareTex, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false });
      const flare = new THREE.Sprite(flareMat);
      flare.position.copy(position);
      flare.scale.set(scale * 2.2, scale * 0.03, 1);
      scene.add(flare);

      const flare2Tex = makeElongatedFlareTexture(Math.round(scale * 1.2), Math.max(2, Math.round(scale * 0.01)), 'rgba(255,255,255,1)');
      const flare2Mat = new THREE.SpriteMaterial({ map: flare2Tex, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false });
      const flare2 = new THREE.Sprite(flare2Mat);
      flare2.position.copy(position);
      flare2.scale.set(scale * 1.2, scale * 0.015, 1);
      scene.add(flare2);

      const vflareTex = makeElongatedFlareTexture(Math.round(scale * 0.8), Math.max(2, Math.round(scale * 0.01)), 'rgba(200,230,255,0.9)');
      const vflareMat = new THREE.SpriteMaterial({ map: vflareTex, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false });
      const vflare = new THREE.Sprite(vflareMat);
      vflare.position.copy(position);
      vflare.scale.set(scale * 0.02, scale * 0.9, 1);
      vflare.material.rotation = Math.PI / 2;
      scene.add(vflare);

      const starObj = { innerCore, core, halo, flare, flare2, vflare, baseScale: scale };
      brightStars.push(starObj);
      return starObj;
    }

    function updateBrightStars(dt) {
      const t = performance.now() * 0.001;
      brightStars.forEach((s, i) => {
        const flick = 1 + Math.sin(t * (0.9 + i*0.37) + i) * 0.025;
        s.innerCore.scale.set(s.baseScale * 0.06 * (1.02 + Math.sin(t * 3.2 + i)*0.03), s.baseScale * 0.06 * (1.02 + Math.sin(t * 3.2 + i)*0.03), 1);
        s.core.scale.set(s.baseScale * 0.12 * flick, s.baseScale * 0.12 * flick, 1);
        s.halo.scale.set(s.baseScale * 0.9 * (1 + (1-flick)*0.08), s.baseScale * 0.56 * (1 + (1-flick)*0.08), 1);
        s.flare.material.opacity = 0.9 * (0.85 + 0.15 * Math.sin(t * 1.3 + i));
        s.flare2.material.opacity = 0.95 * (0.9 + 0.1 * Math.cos(t * 1.7 + i));
        s.vflare.material.opacity = 0.75 * (0.9 + 0.1 * Math.sin(t * 1.1 + i));
      });
    }

    // add a couple of hero stars
    createBrightStar(new THREE.Vector3(-300, 120, -1200), 700);
    createBrightStar(new THREE.Vector3(420, -60, -2000), 420);

    /*********************** Lights ****************************************/
    const light = new THREE.PointLight(0xffffff,1.2,0);
    light.position.set(200,200,200);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0xffffff,0.3));

    /*********************** Movement & ship setup *************************/
    function randomUnit(){
      const v = new THREE.Vector3(Math.random()*2-1, Math.random()*2-1, Math.random()*2-1);
      return v.normalize();
    }
    const sphereRadius = 500;
    let spaceshipPos = randomUnit().multiplyScalar(sphereRadius*0.4);
    let speed = 3.0;
    let spaceshipVel = randomUnit().multiplyScalar(speed);

    // Smooth steering vars
    let desiredVel = spaceshipVel.clone();
    let nextSteerChange = 0;
    const steerMin = 1000;
    const steerMax = 3000;
    const steerLerpFactor = 0.015;
    const maxRoll = 1.0;
    let prevVelDir = spaceshipVel.clone().normalize();

    // Ship & Missile geometry holders
    let spaceship = null;            // current active ship Mesh (or null)
    let spaceshipGeometry = null;    // loaded geometry to clone from
    let spaceshipMaterial = null;    // base material to use for clones
    let missileGeometry = null;
    const loader = new THREE.STLLoader();

    const loadModels = () => {
        const spaceshipPromise = new Promise((resolve, reject) => {
            loader.load('./res/spaceship.stl', (geometry) => {
                geometry.computeBoundingBox();
                const bb = geometry.boundingBox;
                const center = new THREE.Vector3(); bb.getCenter(center);
                geometry.translate(-center.x, -center.y, -center.z);
                // store geometry and material, but DO NOT add a mesh yet — we'll spawn instances
                spaceshipGeometry = geometry;
                spaceshipMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
                resolve();
            }, undefined, reject);
        });

        const missilePromise = new Promise((resolve, reject) => {
            loader.load('./res/missile.stl', (geometry) => {
                geometry.computeBoundingBox();
                const bb = geometry.boundingBox;
                const center = new THREE.Vector3(); bb.getCenter(center);
                geometry.translate(-center.x, -center.y, -center.z);
                missileGeometry = geometry;
                resolve();
            }, undefined, reject);
        });

        return Promise.all([spaceshipPromise, missilePromise]);
    };

    // spawn a new spaceship instance (if we have the geometry)
    function spawnSpaceship() {
      if (!spaceshipGeometry) return;
      if (spaceship) return; // already present - don't spawn another (keeps 1 active ship)
      spaceshipPos = randomUnit().multiplyScalar(sphereRadius*0.4);
      spaceshipVel = randomUnit().multiplyScalar(speed);
      desiredVel = spaceshipVel.clone();
      const mesh = new THREE.Mesh(spaceshipGeometry, spaceshipMaterial.clone());
      mesh.scale.set(0.5, 0.5, 0.5);
      mesh.position.copy(spaceshipPos);
      spaceship = mesh;
      enemyHP = enemyMaxHP;
      updateHP();
      scene.add(spaceship);
      // start enemy firing loop shortly after spawn
      setTimeout(enemyShoot, 1200);
      // hide win message if any
      winDiv.style.display = 'none';
    }

    /*********************** Trail *****************************************/
    const trailParticles = [];
    const trailMaterial = new THREE.MeshBasicMaterial({
      color: 0x00aaff,
      transparent: true,
      opacity: 1
    });
    const trailGeom = new THREE.SphereGeometry(5, 10, 10);
    const BACK_OFFSET = 4.5;
    const DOWN_OFFSET = 7.5;
    function addTrailParticle() {
      if (!spaceship) return;
      const localOffset = new THREE.Vector3(0, BACK_OFFSET, -DOWN_OFFSET);
      const worldOffset = localOffset.applyQuaternion(spaceship.quaternion);
      const worldPos = spaceship.position.clone().add(worldOffset);
      const particle = new THREE.Mesh(trailGeom, trailMaterial.clone());
      particle.position.copy(worldPos);
      trailParticles.push({mesh: particle, life: 1.0});
      scene.add(particle);
    }
    function updateTrail(dt) {
      for (let i = trailParticles.length - 1; i >= 0; i--) {
        const p = trailParticles[i];
        p.life -= dt * 0.7; // fade slower
        if (p.life <= 0) {
          scene.remove(p.mesh);
          trailParticles.splice(i, 1);
          continue;
        }
        p.mesh.material.opacity = 0.9 * (p.life);
      }
    }

    /*********************** HP, bullets & missiles *************************/
    let playerHP = 20;
    let enemyHP = 20; // <-- changed to 20
    const playerMaxHP = 20;
    const enemyMaxHP = 20; // <-- changed to 20

    const winDiv = document.getElementById('win');
    const loseDiv = document.getElementById('lose');

    // Missile total ammo (per-game)
    let missileAmmo = 4; // standardize to 4
    const missileCountSpan = document.getElementById('missileCount');

    // Missile cooldown (ms)
    const missileCooldownMs = 1500; // 1.5s cooldown between missile launches
    let lastMissileTime = -Infinity;

    function updateMissileUI(){
      missileCountSpan.textContent = missileAmmo;
      const ui = document.getElementById('missileCountUI');
      const now = performance.now();
      if (missileAmmo <= 0) {
        ui.textContent = 'No missiles';
      } else {
        const since = now - lastMissileTime;
        if (since >= missileCooldownMs) {
          ui.textContent = 'Missile ready';
        } else {
          const rem = Math.max(0, (missileCooldownMs - since) / 1000);
          ui.textContent = 'Cooldown ' + rem.toFixed(1) + 's';
        }
      }
    }

    // Periodically update UI countdown so it looks smooth
    setInterval(updateMissileUI, 100);

    // HP bar updater (green -> white -> red)
    function setHPbars(containerId, hp, maxHP){
      const seg = maxHP / 3;
      const redDiv   = document.querySelector(`#${containerId} .red`);
      const whiteDiv = document.querySelector(`#${containerId} .white`);
      const greenDiv = document.querySelector(`#${containerId} .green`);
    
      const clamped = Math.max(0, Math.min(hp, maxHP));
      let r = seg, w = seg, g = seg;
      let deficit = maxHP - clamped;
      if(deficit > 0){
        const take = Math.min(deficit, g);
        g -= take; deficit -= take;
      }
      if(deficit > 0){
        const take = Math.min(deficit, w);
        w -= take; deficit -= take;
      }
      if(deficit > 0){
        const take = Math.min(deficit, r);
        r -= take; deficit -= take;
      }
      const unit = 100 / 3;
      redDiv.style.width   = (r / seg * unit) + '%';
      whiteDiv.style.width = (w / seg * unit) + '%';
      greenDiv.style.width = (g / seg * unit) + '%';
    }

    function updateHP(){
      setHPbars('playerBar', playerHP, playerMaxHP);
      setHPbars('enemyBar', enemyHP, enemyMaxHP);
    }
    updateHP();
    updateMissileUI();

    /*********************** Controls *************************************/
    let accel = parseFloat(document.getElementById('sensitivity').value);
    const sensitivityInput = document.getElementById('sensitivity');
    sensitivityInput.addEventListener('input', (e) => {
      accel = parseFloat(e.target.value);
    });
    const keys = {};
    function pressKey(code){ keys[code] = true; }
    function releaseKey(code){ keys[code] = false; }
    window.addEventListener('keydown',(e)=>{
      if(e.code === 'Space'){ shoot(); }
      if(e.code === 'KeyM'){ launchMissile(); }
      else if(e.key === 'r' || e.key === 'R'){ reset(); }
      else pressKey(e.code);
    });
    window.addEventListener('keyup',(e)=>{
      if(e.code !== 'Space' && e.code !== 'KeyM') releaseKey(e.code);
    });
    function updateCamera(){
      if(keys['ArrowDown']) camera.rotateX(-accel);
      if(keys['ArrowUp']) camera.rotateX(accel);
      if(keys['ArrowLeft']) camera.rotateY(accel);
      if(keys['ArrowRight']) camera.rotateY(-accel);
      if(keys['KeyA']) camera.rotateZ(accel);
      if(keys['KeyD']) camera.rotateZ(-accel);
    }
    // Shooting
    const bullets = [];
    const enemyBullets = [];
    const missiles = [];
    const bulletSpeed = 80;
    const missileSpeed = 4;
    function shoot(){
      const bulletGeom = new THREE.SphereGeometry(2,8,8);
      const bulletMat = new THREE.MeshBasicMaterial({color:0xffff00});
      const bullet = new THREE.Mesh(bulletGeom, bulletMat);
      const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize();
      bullet.position.copy(camera.position);
      bullets.push({mesh:bullet,vel:dir.multiplyScalar(bulletSpeed)});
      scene.add(bullet);
    }

    // Missile launch with cooldown check
    function launchMissile(){
      if(!missileGeometry) return;
      const now = performance.now();
      if (missileAmmo <= 0) {
        const ui = document.getElementById('missileCountUI');
        ui.textContent = 'No missiles';
        return;
      }
      if (now - lastMissileTime < missileCooldownMs) {
        const rem = ((missileCooldownMs - (now - lastMissileTime))/1000).toFixed(1);
        const ui = document.getElementById('missileCountUI');
        ui.textContent = 'Cooldown ' + rem + 's';
        ui.style.transform = 'scale(1.05)';
        setTimeout(()=> ui.style.transform = '', 160);
        return;
      }

      lastMissileTime = now;
      missileAmmo--; updateMissileUI();
      const missileMat = new THREE.MeshStandardMaterial({color:0xff0000});
      const missile = new THREE.Mesh(missileGeometry, missileMat);
      missile.scale.set(0.4, 0.4, 0.4);
      const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize();
      missile.position.copy(camera.position.clone().add(dir.clone().multiplyScalar(10)));
      // when creating missile (inside launchMissile)
      missiles.push({
        mesh: missile,
        // use a clone so we don't mutate dir elsewhere
        vel: dir.clone().multiplyScalar(missileSpeed),
        // explicit null if no ship is present
        target: spaceship || null,
        life: 5000 // milliseconds
      });
      scene.add(missile);

      scene.add(missile);
    }

    // Enemy shooting (fires while the ship exists)
    function enemyShoot(){
      if(!spaceship || gameOver) return;
      const bulletGeom = new THREE.SphereGeometry(2,8,8);
      const bulletMat = new THREE.MeshBasicMaterial({color:0x00ffff});
      const bullet = new THREE.Mesh(bulletGeom, bulletMat);
      const dir = camera.position.clone().sub(spaceship.position).normalize();
      bullet.position.copy(spaceship.position);
      enemyBullets.push({mesh:bullet,vel:dir.multiplyScalar(bulletSpeed*0.8)});
      scene.add(bullet);
      const delay = 800 + Math.random()*1200;
      setTimeout(enemyShoot, delay);
    }

    // Model forward
    const modelForwardLocal = new THREE.Vector3(0, -1, 0);
    function alignShipToVelocity(t=0.35){
      if(!spaceship) return;
      if(spaceshipVel.lengthSq() < 1e-6) return;
      const velDir = spaceshipVel.clone().normalize();
      const meshWorldPos = new THREE.Vector3();
      spaceship.getWorldPosition(meshWorldPos);
      const forwardLocalPoint = modelForwardLocal.clone();
      const forwardWorldPoint = spaceship.localToWorld(forwardLocalPoint.clone());
      const forwardWorld = forwardWorldPoint.sub(meshWorldPos).normalize();
      let qdelta = new THREE.Quaternion();
      if(forwardWorld.dot(velDir) < -0.9999){
        const tmp = new THREE.Vector3(1,0,0);
        if(Math.abs(forwardWorld.x) > 0.9) tmp.set(0,1,0);
        const axis = new THREE.Vector3().crossVectors(forwardWorld, tmp).normalize();
        qdelta.setFromAxisAngle(axis, Math.PI);
      } else {
        qdelta.setFromUnitVectors(forwardWorld, velDir);
      }
      const prev = prevVelDir.clone();
      const cur = velDir.clone();
      const angleBetween = Math.acos(Math.min(Math.max(prev.dot(cur), -1), 1));
      const turnAxis = new THREE.Vector3().crossVectors(prev, cur);
      const sign = Math.sign(turnAxis.dot(new THREE.Vector3(0,1,0)) || 1);
      const desiredRoll = Math.max(-maxRoll, Math.min(maxRoll, sign * angleBetween * 1.8));
      const rollQuat = new THREE.Quaternion().setFromAxisAngle(velDir.clone(), desiredRoll);
      const currentQ = spaceship.quaternion.clone();
      const baseTargetQ = qdelta.multiply(currentQ);
      const targetQ = rollQuat.multiply(baseTargetQ);
      if(t >= 1) spaceship.quaternion.copy(targetQ);
      else spaceship.quaternion.slerp(targetQ, t);
      prevVelDir.lerp(velDir, 0.15).normalize();
    }
    // Steering
    function pickNewDesired(){
      desiredVel = randomUnit().multiplyScalar(speed);
      nextSteerChange = performance.now() + steerMin + Math.random()*(steerMax - steerMin);
    }
    pickNewDesired();

    // --- NEW: G control config ---
    const distanceAhead = 800;
    const steerTowardCrossLerp = 0.08;
    // --- end new config ---

    function stepSpaceship(dt){
      if (!spaceship) return; // no active ship to step

      // G steering override
      if (keys['KeyG'] && camera) {
        const camForward = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize();
        const targetPoint = camera.position.clone().add(camForward.multiplyScalar(distanceAhead));
        const desiredToPoint = targetPoint.clone().sub(spaceshipPos).normalize().multiplyScalar(speed);
        spaceshipVel.lerp(desiredToPoint, Math.min(1, steerTowardCrossLerp * (dt * 60)));
        desiredVel.copy(spaceshipVel);
        nextSteerChange = performance.now() + 400;
      } else {
        if(performance.now() > nextSteerChange){
          pickNewDesired();
        }
        const lerpAmt = Math.min(1, steerLerpFactor * (dt*60));
        spaceshipVel.lerp(desiredVel, lerpAmt);
      }

      spaceshipVel.setLength(speed);
      spaceshipPos.add(spaceshipVel.clone().multiplyScalar(dt * 60));
      const dist = spaceshipPos.length();
      if(dist >= sphereRadius){
        const normal = spaceshipPos.clone().normalize();
        spaceshipPos.copy(normal.clone().multiplyScalar(sphereRadius - 1));
        const v = spaceshipVel.clone();
        const dot = v.dot(normal);
        const reflected = v.clone().sub(normal.clone().multiplyScalar(2*dot));
        spaceshipVel.copy(reflected.setLength(speed));
        desiredVel.copy(spaceshipVel);
      }
      if(spaceship){
        spaceship.position.copy(spaceshipPos);
        alignShipToVelocity(0.25);
      }
    }

    // Defeated ships counter & helper
    let defeatedCount = 0;
    const defeatedEl = document.getElementById('defeatedCount');
    function updateDefeatedUI(){ defeatedEl.textContent = defeatedCount; }

    function destroyCurrentEnemy(){
      if (!spaceship) return;
      // remove mesh and clear variables
      scene.remove(spaceship);
      spaceship = null;
      // cleanup any enemy bullets still in flight
      for (let i = enemyBullets.length - 1; i >= 0; i--) {
        scene.remove(enemyBullets[i].mesh);
        enemyBullets.splice(i, 1);
      }
      defeatedCount++;
      updateDefeatedUI();
      winDiv.style.display = 'block';
      // hide brief popup after 1.8s
      setTimeout(()=> { if(winDiv) winDiv.style.display = 'none'; }, 1800);
    }

    // --- IMPORTANT: declare arrow BEFORE animate so animate can use it ---
    const arrow = document.getElementById('arrowIndicator');

    // Animation loop
    let last = performance.now();
    let gameOver = false;
    let trailTimer = 0;

    // Autoshoot state
    let autoShooting = false;
    let autoIntervalId = null;
    const autoShootRateMs = 120; // bullets per 120ms
    function setAutoShooting(on){
      const btn = document.getElementById('autoShootBtn');
      if(on){
        if(autoIntervalId) clearInterval(autoIntervalId);
        autoIntervalId = setInterval(()=>{ if(!gameOver) shoot(); else setAutoShooting(false); }, autoShootRateMs);
        autoShooting = true;
        btn.classList.add('active');
      } else {
        if(autoIntervalId) clearInterval(autoIntervalId);
        autoIntervalId = null;
        autoShooting = false;
        btn.classList.remove('active');
      }
    }
    document.getElementById('autoShootBtn').addEventListener('click', ()=> setAutoShooting(!autoShooting));

    function animate(t){
      requestAnimationFrame(animate);
      if(gameOver) return;
      const now = t || performance.now();
      const dt = Math.min((now - last)/1000, 0.1);
      last = now;

      // Update only if spaceship exists
      stepSpaceship(dt);

      // spawn trail more frequently
      trailTimer += dt;
      while (trailTimer > 0.02) { // every 0.02s (~50 per second)
        addTrailParticle();
        trailTimer -= 0.02;
      }
      updateTrail(dt);
      updateBrightStars(dt);

      // bullets
      for(let i=bullets.length-1;i>=0;i--){
        const b = bullets[i];
        b.mesh.position.add(b.vel.clone().multiplyScalar(dt*60));
        if(b.mesh.position.length()>sphereRadius*2){ scene.remove(b.mesh); bullets.splice(i,1); continue; }
        if(spaceship && b.mesh.position.distanceTo(spaceship.position) < 20){
          scene.remove(b.mesh); bullets.splice(i,1);
          enemyHP--; updateHP();
          if(enemyHP<=0){
            destroyCurrentEnemy();
          }
        }
      }
      // missiles
      // missiles (defensive, guards against undefined / stale target)
      for (let i = missiles.length - 1; i >= 0; i--) {
        const m = missiles[i];
      
        // If the entry is corrupted or missing, remove it and continue
        if (!m || !m.mesh) {
          missiles.splice(i, 1);
          continue;
        }
      
        // If target reference was removed from the scene, clear it safely
        if (m.target && !scene.getObjectById(m.target.id)) {
          m.target = null;
        }
      
        // If we still have a valid target and a live spaceship, steer toward it
        if (m.target && spaceship) {
          const targetDir = m.target.position.clone().sub(m.mesh.position).normalize();
          m.vel.lerp(targetDir.multiplyScalar(missileSpeed), 0.1);
        }
      
        // Update missile position
        m.mesh.position.add(m.vel.clone().multiplyScalar(dt * 60));
      
        // Orientation (avoid zero-length dir)
        const forwardAxis = new THREE.Vector3(0, 1, 0);
        const velDir = m.vel.clone().normalize();
        if (!velDir.lengthSq()) velDir.set(0, 1, 0);
        m.mesh.quaternion.setFromUnitVectors(forwardAxis, velDir);
      
        // Lifetime and collisions
        if (m.mesh.position.length() > sphereRadius * 2 || (m.life -= dt * 1000) <= 0) {
          scene.remove(m.mesh);
          missiles.splice(i, 1);
          continue;
        }
      
        if (spaceship && m.mesh.position.distanceTo(spaceship.position) < 25) {
          // hit
          scene.remove(m.mesh);
          missiles.splice(i, 1);
          enemyHP -= 3;
          updateHP();
          if (enemyHP <= 0) { destroyCurrentEnemy(); }
        }
      }


      for(let i=enemyBullets.length-1;i>=0;i--){
        const b = enemyBullets[i];
        b.mesh.position.add(b.vel.clone().multiplyScalar(dt*60));
        if(b.mesh.position.length()>sphereRadius*2){ scene.remove(b.mesh); enemyBullets.splice(i,1); continue; }
        if(b.mesh.position.distanceTo(camera.position) < 10){
          scene.remove(b.mesh); enemyBullets.splice(i,1);
          playerHP--; updateHP();
          if(playerHP<=0){ loseDiv.style.display='block'; gameOver=true; setAutoShooting(false); }
        }
      }
      updateCamera();
     // Arrow Indicator
      if (spaceship) {
        const pos = spaceship.position.clone();
        const vector = pos.project(camera);
        const halfW = window.innerWidth / 2;
        const halfH = window.innerHeight / 2;
        // Convert to screen space
        let x = (vector.x * halfW) + halfW;
        let y = (-vector.y * halfH) + halfH;
        // Check if target is in front or behind
        let dirX = x - halfW;
        let dirY = y - halfH;
        if (vector.z > 1) {
          // Behind camera → flip direction
          dirX = -dirX;
          dirY = -dirY;
        }
        // On screen?
        if (vector.z < 1 &&
            x >= 0 && x <= window.innerWidth &&
            y >= 0 && y <= window.innerHeight) {
          // On screen → hide arrow
          arrow.style.display = "none";
        } else {
          // Off screen → show arrow
          arrow.style.display = "block";
          const angle = Math.atan2(dirY, dirX);
          // Push arrow to screen edge
          const edgeBuffer = 40;
          const slope = dirY / dirX;
          if (Math.abs(dirX) > Math.abs(dirY)) {
            // hits left/right border
            x = dirX > 0 ? window.innerWidth - edgeBuffer : edgeBuffer;
            y = halfH + slope * (x - halfW);
          } else {
            // hits top/bottom border
            y = dirY > 0 ? window.innerHeight - edgeBuffer : edgeBuffer;
            x = halfW + (y - halfH) / slope;
          }
          arrow.style.left = `${x - 12}px`;
          arrow.style.top = `${y - 12}px`;
          arrow.style.transform = `rotate(${angle}rad)`;
        }
      } else {
        arrow.style.display = "none";
      }
      renderer.render(scene, camera);
    }

    // Main execution
    loadModels().then(() => {
        // spawn first ship immediately
        spawnSpaceship();
        animate();
        // spawn a ship every 30 seconds if none exists
        setInterval(()=> {
          if (!spaceship) spawnSpaceship();
        }, 30000);
    }).catch(error => {
        console.error('Error loading models:', error);
    });

    // Reset
    function reset(){
      playerHP=20; enemyHP=20; updateHP(); // reset hp
      missileAmmo = 4; lastMissileTime = -Infinity; updateMissileUI();
      winDiv.style.display='none'; loseDiv.style.display='none';
      gameOver=false;
      setAutoShooting(false);
      spaceshipPos = randomUnit().multiplyScalar(sphereRadius*0.4);
      spaceshipVel = randomUnit().multiplyScalar(speed);
      desiredVel = spaceshipVel.clone();
      if(spaceship) {
        // put ship to new pos
        spaceship.position.copy(spaceshipPos);
      } else {
        // if no ship, spawn one immediately
        spawnSpaceship();
      }
      bullets.forEach(b=>scene.remove(b.mesh)); bullets.length=0;
      enemyBullets.forEach(b=>scene.remove(b.mesh)); enemyBullets.length=0;
      missiles.forEach(m=>scene.remove(m.mesh)); missiles.length=0;
      trailParticles.forEach(p=>scene.remove(p.mesh)); trailParticles.length=0;
      // reset defeated counter
      defeatedCount = 0; updateDefeatedUI();
    }
    // Reset button
    document.getElementById('resetBtn').addEventListener('click', reset);
    document.getElementById('shootBtn').addEventListener('click', shoot);
    document.getElementById('missileBtn').addEventListener('click', launchMissile);
    document.getElementById('rollLeft').addEventListener('mousedown',()=>pressKey('KeyA'));
    document.getElementById('rollLeft').addEventListener('mouseup',()=>releaseKey('KeyA'));
    document.getElementById('rollRight').addEventListener('mousedown',()=>pressKey('KeyD'));
    document.getElementById('rollRight').addEventListener('mouseup',()=>releaseKey('KeyD'));
    // Resize
    window.addEventListener('resize',()=>{
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>

<!doctype html>
<html lang="en">
<head>
Â  <meta charset="utf-8" />
Â  <meta name="viewport" content="width=device-width, initial-scale=1" />
Â  <title>Ball Shooter â€” Smooth Turning & Banking2</title>
Â  <style>
Â  Â  html,body{height:100%;margin:0;background:#000;color:#ddd;font-family:system-ui,-apple-system,Segoe UI,Roboto;overflow:hidden}
Â  Â  #overlay{position:fixed;left:12px;top:12px;z-index:10;max-width:360px}
Â  Â  .panel{background:rgba(0,0,0,0.45);padding:12px;border-radius:8px;backdrop-filter:blur(4px)}
Â  Â  #win,#lose{display:none;padding:18px;margin-top:12px;border-radius:8px;font-weight:700}
Â  Â  #win{background:linear-gradient(90deg,#0f0,#005500);color:#001}
Â  Â  #lose{background:linear-gradient(90deg,#f00,#550000);color:#fff}
Â  Â  #canvas-container{width:100%;height:100vh;display:block}
Â  Â  input[type=range]{width:100%}
Â  Â  label{font-size:13px;display:block;margin-top:10px}
Â  Â  #crosshair{position:fixed;left:50%;top:50%;width:20px;height:20px;margin-left:-10px;margin-top:-10px;z-index:5;pointer-events:none}
Â  Â  #crosshair:before,#crosshair:after{content:"";position:absolute;background:#fff}
Â  Â  #crosshair:before{left:9px;top:0;width:2px;height:20px}
Â  Â  #crosshair:after{left:0;top:9px;width:20px;height:2px}
Â  Â  #joystick { position:fixed; bottom:80px; left:80px; width:120px; height:120px; background:rgba(255,255,255,0.1); border-radius:50%; touch-action:none; z-index:20;}
Â  Â  #stick { position:absolute; left:50%; top:50%; width:50px; height:50px; margin-left:-25px; margin-top:-25px; background:rgba(255,255,255,0.3); border-radius:50%;}
Â  Â  #buttons { position:fixed; bottom:80px; right:80px; display:flex; flex-direction:column; gap:12px; z-index:20;}
Â  Â  #buttons button { width:70px; height:70px; border-radius:50%; border:none; background:rgba(255,255,255,0.2); color:#fff; font-size:18px;}
Â  Â  #hud { position:fixed; top:10px; left:0; right:0; display:flex; justify-content:space-between; padding:0 20px; z-index:15; }
Â  Â  .barContainer { width:180px; height:20px; background:rgba(255,255,255,0.2); border:1px solid #888; border-radius:10px; overflow:hidden;}
Â  Â  .barFill { height:100%; width:100%; }
Â  Â  #playerBar { background:linear-gradient(90deg,#0f0,#070); }
Â  Â  #enemyBar { background:linear-gradient(90deg,#f00,#700); }
Â  Â  #arrowIndicator {
Â  Â  Â  position: fixed;
Â  Â  Â  width: 0;
Â  Â  Â  height: 0;
Â  Â  Â  border-left: 12px solid transparent;
Â  Â  Â  border-right: 12px solid transparent;
Â  Â  Â  border-bottom: 20px solid yellow;
Â  Â  Â  z-index: 50;
Â  Â  Â  transform-origin: center;
Â  Â  Â  pointer-events: none;
Â  Â  Â  display: none;
Â  Â  }
Â  </style>
</head>
<body>
Â  <div id="overlay">
Â  Â  <div class="panel">
Â  Â  Â  <div><strong>Ball Shooter Competition â€” Smooth Turning</strong></div>
Â  Â  Â  <ul style="margin:8px 0 0 18px;font-size:13px">
Â  Â  Â  Â  <li>Arrow keys / Joystick: pitch & yaw</li>
Â  Â  Â  Â  <li>A / D buttons: roll</li>
Â  Â  Â  Â  <li>Shoot button / Space: fire</li>
Â  Â  Â  Â  <li>M: launch missile</li>
Â  Â  Â  Â  <li>R: reset</li>
Â  Â  Â  </ul>
Â  Â  Â  <label for="sensitivity">Rotation sensitivity</label>
Â  Â  Â  <input id="sensitivity" type="range" min="0.005" max="3" step="0.002" value="0.015">
Â  Â  Â  <button id="resetBtn">Reset</button>
Â  Â  Â  <div id="win">You destroyed the spaceship â€” you win! ğŸ‰</div>
Â  Â  Â  <div id="lose">The spaceship destroyed you! âŒ</div>
Â  Â  </div>
Â  </div>
Â  <div id="hud">
Â  Â  <div class="barContainer"><div id="playerBar" class="barFill"></div></div>
Â  Â  <div class="barContainer"><div id="enemyBar" class="barFill"></div></div>
Â  </div>
Â  <div id="crosshair"></div>
Â  <div id="canvas-container"></div>
Â  <div id="arrowIndicator"></div>
Â  <div id="joystick"><div id="stick"></div></div>
Â  <div id="buttons">
Â  Â  <button id="shootBtn">Shoot</button>
Â  Â  <button id="rollLeft">A</button>
Â  Â  <button id="rollRight">D</button>
Â  </div>
Â  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
Â  <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/loaders/STLLoader.js"></script>
Â  <script>
Â  Â  const container = document.getElementById('canvas-container');
Â  Â  const scene = new THREE.Scene();
Â  Â  const renderer = new THREE.WebGLRenderer({antialias:true});
Â  Â  renderer.setPixelRatio(window.devicePixelRatio);
Â  Â  renderer.setSize(window.innerWidth, window.innerHeight);
Â  Â  container.appendChild(renderer.domElement);
Â  Â  const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 5000);
Â  Â  camera.position.set(0,0,0);
Â  Â  // Stars
Â  Â  function createStars(){
Â  Â  Â  const starCount = 3000;
Â  Â  Â  const geom = new THREE.BufferGeometry();
Â  Â  Â  const positions = new Float32Array(starCount*3);
Â  Â  Â  for(let i=0;i<starCount;i++){
Â  Â  Â  Â  positions[i*3+0] = (Math.random()-0.5)*4000;
Â  Â  Â  Â  positions[i*3+1] = (Math.random()-0.5)*4000;
Â  Â  Â  Â  positions[i*3+2] = (Math.random()-0.5)*4000;
Â  Â  Â  }
Â  Â  Â  geom.setAttribute('position', new THREE.BufferAttribute(positions,3));
Â  Â  Â  const mat = new THREE.PointsMaterial({color:0xffffff,size:1.5,sizeAttenuation:true});
Â  Â  Â  return new THREE.Points(geom,mat);
Â  Â  }
Â  Â  scene.add(createStars());
Â  Â  // Lights
Â  Â  const light = new THREE.PointLight(0xffffff,1.2,0);
Â  Â  light.position.set(200,200,200);
Â  Â  scene.add(light);
Â  Â  scene.add(new THREE.AmbientLight(0xffffff,0.3));
Â  Â  // Movement state
Â  Â  function randomUnit(){
Â  Â  Â  const v = new THREE.Vector3(Math.random()*2-1, Math.random()*2-1, Math.random()*2-1);
Â  Â  Â  return v.normalize();
Â  Â  }
Â  Â  const sphereRadius = 500;
Â  Â  let spaceshipPos = randomUnit().multiplyScalar(sphereRadius*0.4);
Â  Â  let speed = 3.0;
Â  Â  let spaceshipVel = randomUnit().multiplyScalar(speed);
Â  Â  // Smooth steering vars
Â  Â  let desiredVel = spaceshipVel.clone();
Â  Â  let nextSteerChange = 0;
Â  Â  const steerMin = 1000;
Â  Â  const steerMax = 3000;
Â  Â  const steerLerpFactor = 0.015;
Â  Â  const maxRoll = 1.0;
Â  Â  let prevVelDir = spaceshipVel.clone().normalize();
Â  Â  // Ship & Missile
Â  Â  let spaceship = null;
Â  Â  let missileGeometry = null;
Â  Â  const loader = new THREE.STLLoader();

Â  Â  const loadModels = () => {
Â  Â  Â  Â  const spaceshipPromise = new Promise((resolve, reject) => {
Â  Â  Â  Â  Â  Â  loader.load('./res/spaceship.stl', (geometry) => {
Â  Â  Â  Â  Â  Â  Â  Â  geometry.computeBoundingBox();
Â  Â  Â  Â  Â  Â  Â  Â  const bb = geometry.boundingBox;
Â  Â  Â  Â  Â  Â  Â  Â  const center = new THREE.Vector3(); bb.getCenter(center);
Â  Â  Â  Â  Â  Â  Â  Â  geometry.translate(-center.x, -center.y, -center.z);
Â  Â  Â  Â  Â  Â  Â  Â  const mat = new THREE.MeshStandardMaterial({ color: 0xffffff });
Â  Â  Â  Â  Â  Â  Â  Â  spaceship = new THREE.Mesh(geometry, mat);
Â  Â  Â  Â  Â  Â  Â  Â  spaceship.scale.set(0.5, 0.5, 0.5);
Â  Â  Â  Â  Â  Â  Â  Â  spaceship.position.copy(spaceshipPos);
Â  Â  Â  Â  Â  Â  Â  Â  resolve();
Â  Â  Â  Â  Â  Â  }, undefined, reject);
Â  Â  Â  Â  });

Â  Â  Â  Â  const missilePromise = new Promise((resolve, reject) => {
Â  Â  Â  Â  Â  Â  loader.load('./res/missile.stl', (geometry) => {
Â  Â  Â  Â  Â  Â  Â  Â  geometry.computeBoundingBox();
Â  Â  Â  Â  Â  Â  Â  Â  const bb = geometry.boundingBox;
Â  Â  Â  Â  Â  Â  Â  Â  const center = new THREE.Vector3(); bb.getCenter(center);
Â  Â  Â  Â  Â  Â  Â  Â  geometry.translate(-center.x, -center.y, -center.z);
Â  Â  Â  Â  Â  Â  Â  Â  missileGeometry = geometry;
Â  Â  Â  Â  Â  Â  Â  Â  resolve();
Â  Â  Â  Â  Â  Â  }, undefined, reject);
Â  Â  Â  Â  });

Â  Â  Â  Â  return Promise.all([spaceshipPromise, missilePromise]);
Â  Â  };

Â  Â  // Trail
Â  Â  const trailParticles = [];
Â  Â  const trailMaterial = new THREE.MeshBasicMaterial({
Â  Â  Â  color: 0x00aaff,
Â  Â  Â  transparent: true,
Â  Â  Â  opacity: 1
Â  Â  });
Â  Â  const trailGeom = new THREE.SphereGeometry(5, 10, 10);
Â  Â  const BACK_OFFSET = 4.5;
Â  Â  const DOWN_OFFSET = 7.5;
Â  Â  function addTrailParticle() {
Â  Â  Â  if (!spaceship) return;
Â  Â  Â  const localOffset = new THREE.Vector3(0, BACK_OFFSET, -DOWN_OFFSET);
Â  Â  Â  const worldOffset = localOffset.applyQuaternion(spaceship.quaternion);
Â  Â  Â  const worldPos = spaceship.position.clone().add(worldOffset);
Â  Â  Â  const particle = new THREE.Mesh(trailGeom, trailMaterial.clone());
Â  Â  Â  particle.position.copy(worldPos);
Â  Â  Â  trailParticles.push({mesh: particle, life: 1.0});
Â  Â  Â  scene.add(particle);
Â  Â  }
Â  Â  function updateTrail(dt) {
Â  Â  Â  for (let i = trailParticles.length - 1; i >= 0; i--) {
Â  Â  Â  Â  const p = trailParticles[i];
Â  Â  Â  Â  p.life -= dt * 0.7; // fade slower
Â  Â  Â  Â  if (p.life <= 0) {
Â  Â  Â  Â  Â  scene.remove(p.mesh);
Â  Â  Â  Â  Â  trailParticles.splice(i, 1);
Â  Â  Â  Â  Â  continue;
Â  Â  Â  Â  }
Â  Â  Â  Â  p.mesh.material.opacity = 0.9 * (p.life);
Â  Â  Â  }
Â  Â  }
Â  Â  // Bullets + HP
Â  Â  let playerHP = 20;
Â  Â  let enemyHP = 10;
Â  Â  const playerBar = document.getElementById('playerBar');
Â  Â  const enemyBar = document.getElementById('enemyBar');
Â  Â  const winDiv = document.getElementById('win');
Â  Â  const loseDiv = document.getElementById('lose');
Â  Â  function updateHP(){ playerBar.style.width = (playerHP/20*100) + "%"; enemyBar.style.width = (enemyHP/10*100) + "%"; }
Â  Â  updateHP();
Â  Â  // Controls
Â  Â  let accel = parseFloat(document.getElementById('sensitivity').value);
Â  Â  const sensitivityInput = document.getElementById('sensitivity');
Â  Â  sensitivityInput.addEventListener('input', (e) => {
Â  Â  Â  accel = parseFloat(e.target.value);
Â  Â  });
Â  Â  const keys = {};
Â  Â  function pressKey(code){ keys[code] = true; }
Â  Â  function releaseKey(code){ keys[code] = false; }
Â  Â  window.addEventListener('keydown',(e)=>{
Â  Â  Â  if(e.code === 'Space'){ shoot(); }
Â  Â  Â  if(e.code === 'KeyM'){ launchMissile(); }
Â  Â  Â  else if(e.key === 'r' || e.key === 'R'){ reset(); }
Â  Â  Â  else pressKey(e.code);
Â  Â  });
Â  Â  window.addEventListener('keyup',(e)=>{
Â  Â  Â  if(e.code !== 'Space' && e.code !== 'KeyM') releaseKey(e.code);
Â  Â  });
Â  Â  function updateCamera(){
Â  Â  Â  if(keys['ArrowDown']) camera.rotateX(-accel);
Â  Â  Â  if(keys['ArrowUp']) camera.rotateX(accel);
Â  Â  Â  if(keys['ArrowLeft']) camera.rotateY(accel);
Â  Â  Â  if(keys['ArrowRight']) camera.rotateY(-accel);
Â  Â  Â  if(keys['KeyA']) camera.rotateZ(accel);
Â  Â  Â  if(keys['KeyD']) camera.rotateZ(-accel);
Â  Â  }
Â  Â  // Shooting
Â  Â  const bullets = [];
Â  Â  const enemyBullets = [];
Â  Â  const missiles = [];
Â  Â  const bulletSpeed = 20;
Â  Â  const missileSpeed = 15;
Â  Â  function shoot(){
Â  Â  Â  const bulletGeom = new THREE.SphereGeometry(2,8,8);
Â  Â  Â  const bulletMat = new THREE.MeshBasicMaterial({color:0xffff00});
Â  Â  Â  const bullet = new THREE.Mesh(bulletGeom, bulletMat);
Â  Â  Â  const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize();
Â  Â  Â  bullet.position.copy(camera.position);
Â  Â  Â  bullets.push({mesh:bullet,vel:dir.multiplyScalar(bulletSpeed)});
Â  Â  Â  scene.add(bullet);
Â  Â  }
Â  Â  function launchMissile(){
Â  Â  Â  // missile limit check
Â  Â  Â  if(missiles.length >= 3){
Â  Â  Â  Â  console.log("Missile limit reached! (3)");
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â  if(!missileGeometry) return;
Â  Â  Â  const missileMat = new THREE.MeshStandardMaterial({color:0xff0000});
Â  Â  Â  const missile = new THREE.Mesh(missileGeometry, missileMat);
Â  Â  Â  // increased size
Â  Â  Â  missile.scale.set(0.2, 0.2, 0.2); // changed from 0.1 to 0.2
Â  Â  Â  const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize();
Â  Â  Â  missile.position.copy(camera.position.clone().add(dir.clone().multiplyScalar(10)));
Â  Â  Â  missiles.push({
Â  Â  Â  Â  mesh: missile,
Â  Â  Â  Â  vel: dir.multiplyScalar(missileSpeed),
Â  Â  Â  Â  target: spaceship,
Â  Â  Â  Â  life: 5000 // In milliseconds
Â  Â  Â  });
Â  Â  Â  scene.add(missile);
Â  Â  }
Â  Â  function enemyShoot(){
Â  Â  Â  if(gameOver || !spaceship) return;
Â  Â  Â  const bulletGeom = new THREE.SphereGeometry(2,8,8);
Â  Â  Â  const bulletMat = new THREE.MeshBasicMaterial({color:0x00ffff});
Â  Â  Â  const bullet = new THREE.Mesh(bulletGeom, bulletMat);
Â  Â  Â  const dir = camera.position.clone().sub(spaceship.position).normalize();
Â  Â  Â  bullet.position.copy(spaceship.position);
Â  Â  Â  enemyBullets.push({mesh:bullet,vel:dir.multiplyScalar(bulletSpeed*0.8)});
Â  Â  Â  scene.add(bullet);
Â  Â  Â  const delay = 800 + Math.random()*1200;
Â  Â  Â  setTimeout(enemyShoot, delay);
Â  Â  }
Â  Â  setTimeout(enemyShoot, 1200);
Â  Â  // Model forward
Â  Â  const modelForwardLocal = new THREE.Vector3(0, -1, 0);
Â  Â  function alignShipToVelocity(t=0.35){
Â  Â  Â  if(!spaceship) return;
Â  Â  Â  if(spaceshipVel.lengthSq() < 1e-6) return;
Â  Â  Â  const velDir = spaceshipVel.clone().normalize();
Â  Â  Â  const meshWorldPos = new THREE.Vector3();
Â  Â  Â  spaceship.getWorldPosition(meshWorldPos);
Â  Â  Â  const forwardLocalPoint = modelForwardLocal.clone();
Â  Â  Â  const forwardWorldPoint = spaceship.localToWorld(forwardLocalPoint.clone());
Â  Â  Â  const forwardWorld = forwardWorldPoint.sub(meshWorldPos).normalize();
Â  Â  Â  let qdelta = new THREE.Quaternion();
Â  Â  Â  if(forwardWorld.dot(velDir) < -0.9999){
Â  Â  Â  Â  const tmp = new THREE.Vector3(1,0,0);
Â  Â  Â  Â  if(Math.abs(forwardWorld.x) > 0.9) tmp.set(0,1,0);
Â  Â  Â  Â  const axis = new THREE.Vector3().crossVectors(forwardWorld, tmp).normalize();
Â  Â  Â  Â  qdelta.setFromAxisAngle(axis, Math.PI);
Â  Â  Â  } else {
Â  Â  Â  Â  qdelta.setFromUnitVectors(forwardWorld, velDir);
Â  Â  Â  }
Â  Â  Â  const prev = prevVelDir.clone();
Â  Â  Â  const cur = velDir.clone();
Â  Â  Â  const angleBetween = Math.acos(Math.min(Math.max(prev.dot(cur), -1), 1));
Â  Â  Â  const turnAxis = new THREE.Vector3().crossVectors(prev, cur);
Â  Â  Â  const sign = Math.sign(turnAxis.dot(new THREE.Vector3(0,1,0)) || 1);
Â  Â  Â  const desiredRoll = Math.max(-maxRoll, Math.min(maxRoll, sign * angleBetween * 1.8));
Â  Â  Â  const rollQuat = new THREE.Quaternion().setFromAxisAngle(velDir.clone(), desiredRoll);
Â  Â  Â  const currentQ = spaceship.quaternion.clone();
Â  Â  Â  const baseTargetQ = qdelta.multiply(currentQ);
Â  Â  Â  const targetQ = rollQuat.multiply(baseTargetQ);
Â  Â  Â  if(t >= 1) spaceship.quaternion.copy(targetQ);
Â  Â  Â  else spaceship.quaternion.slerp(targetQ, t);
Â  Â  Â  prevVelDir.lerp(velDir, 0.15).normalize();
Â  Â  }
Â  Â  // Steering
Â  Â  function pickNewDesired(){
Â  Â  Â  desiredVel = randomUnit().multiplyScalar(speed);
Â  Â  Â  nextSteerChange = performance.now() + steerMin + Math.random()*(steerMax - steerMin);
Â  Â  }
Â  Â  pickNewDesired();
Â  Â  function stepSpaceship(dt){
Â  Â  Â  if(performance.now() > nextSteerChange){
Â  Â  Â  Â  pickNewDesired();
Â  Â  Â  }
Â  Â  Â  const lerpAmt = Math.min(1, steerLerpFactor * (dt*60));
Â  Â  Â  spaceshipVel.lerp(desiredVel, lerpAmt);
Â  Â  Â  spaceshipVel.setLength(speed);
Â  Â  Â  spaceshipPos.add(spaceshipVel.clone().multiplyScalar(dt * 60));
Â  Â  Â  const dist = spaceshipPos.length();
Â  Â  Â  if(dist >= sphereRadius){
Â  Â  Â  Â  const normal = spaceshipPos.clone().normalize();
Â  Â  Â  Â  spaceshipPos.copy(normal.clone().multiplyScalar(sphereRadius - 1));
Â  Â  Â  Â  const v = spaceshipVel.clone();
Â  Â  Â  Â  const dot = v.dot(normal);
Â  Â  Â  Â  const reflected = v.clone().sub(normal.clone().multiplyScalar(2*dot));
Â  Â  Â  Â  spaceshipVel.copy(reflected.setLength(speed));
Â  Â  Â  Â  desiredVel.copy(spaceshipVel);
Â  Â  Â  }
Â  Â  Â  if(spaceship){
Â  Â  Â  Â  spaceship.position.copy(spaceshipPos);
Â  Â  Â  Â  alignShipToVelocity(0.25);
Â  Â  Â  }
Â  Â  }
Â  Â  // Arrow indicator
Â  Â  const arrow = document.getElementById('arrowIndicator');
Â  Â  // Animation loop
Â  Â  let last = performance.now();
Â  Â  let gameOver = false;
Â  Â  let trailTimer = 0;
Â  Â  function animate(t){
Â  Â  Â  requestAnimationFrame(animate);
Â  Â  Â  if(gameOver) return;
Â  Â  Â  const now = t || performance.now();
Â  Â  Â  const dt = Math.min((now - last)/1000, 0.1);
Â  Â  Â  last = now;
Â  Â  Â  stepSpaceship(dt);
Â  Â  Â  // spawn trail more frequently
Â  Â  Â  trailTimer += dt;
Â  Â  Â  while (trailTimer > 0.02) { // every 0.02s (~50 per second)
Â  Â  Â  Â  addTrailParticle();
Â  Â  Â  Â  trailTimer -= 0.02;
Â  Â  Â  }
Â  Â  Â  updateTrail(dt);
Â  Â  Â  // bullets
Â  Â  Â  for(let i=bullets.length-1;i>=0;i--){
Â  Â  Â  Â  const b = bullets[i];
Â  Â  Â  Â  b.mesh.position.add(b.vel.clone().multiplyScalar(dt*60));
Â  Â  Â  Â  if(b.mesh.position.length()>sphereRadius*2){ scene.remove(b.mesh); bullets.splice(i,1); continue; }
Â  Â  Â  Â  if(spaceship && b.mesh.position.distanceTo(spaceship.position) < 20){
Â  Â  Â  Â  Â  scene.remove(b.mesh); bullets.splice(i,1);
Â  Â  Â  Â  Â  enemyHP--; updateHP();
Â  Â  Â  Â  Â  if(enemyHP<=0){ winDiv.style.display='block'; gameOver=true; }
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  Â  // missiles
Â  Â  Â  for(let i=missiles.length-1;i>=0;i--){
Â  Â  Â  Â  const m = missiles[i];
Â  Â  Â  Â  if (m.target) {
Â  Â  Â  Â  Â  const targetDir = m.target.position.clone().sub(m.mesh.position).normalize();
Â  Â  Â  Â  Â  m.vel.lerp(targetDir.multiplyScalar(missileSpeed), 0.1);
Â  Â  Â  Â  }
Â  Â  Â  Â  m.mesh.position.add(m.vel.clone().multiplyScalar(dt * 60));
Â  Â  Â  Â  m.mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), m.vel.clone().normalize());
Â  Â  Â  Â  if(m.mesh.position.length()>sphereRadius*2 || (m.life-=dt*1000)<=0){ scene.remove(m.mesh); missiles.splice(i,1); continue; }
Â  Â  Â  Â  if(spaceship && m.mesh.position.distanceTo(spaceship.position) < 25){
Â  Â  Â  Â  Â  scene.remove(m.mesh); missiles.splice(i,1);
Â  Â  Â  Â  Â  enemyHP -= 3; updateHP();
Â  Â  Â  Â  Â  if(enemyHP<=0){ winDiv.style.display='block'; gameOver=true; }
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  Â  for(let i=enemyBullets.length-1;i>=0;i--){
Â  Â  Â  Â  const b = enemyBullets[i];
Â  Â  Â  Â  b.mesh.position.add(b.vel.clone().multiplyScalar(dt*60));
Â  Â  Â  Â  if(b.mesh.position.length()>sphereRadius*2){ scene.remove(b.mesh); enemyBullets.splice(i,1); continue; }
Â  Â  Â  Â  if(b.mesh.position.distanceTo(camera.position) < 10){
Â  Â  Â  Â  Â  scene.remove(b.mesh); enemyBullets.splice(i,1);
Â  Â  Â  Â  Â  playerHP--; updateHP();
Â  Â  Â  Â  Â  if(playerHP<=0){ loseDiv.style.display='block'; gameOver=true; }
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  Â  updateCamera();
Â  Â  Â // Arrow Indicator
Â  Â  Â  if (spaceship) {
Â  Â  Â  Â  const pos = spaceship.position.clone();
Â  Â  Â  Â  const vector = pos.project(camera);
Â  Â  Â  Â  const halfW = window.innerWidth / 2;
Â  Â  Â  Â  const halfH = window.innerHeight / 2;
Â  Â  Â  Â  // Convert to screen space
Â  Â  Â  Â  let x = (vector.x * halfW) + halfW;
Â  Â  Â  Â  let y = (-vector.y * halfH) + halfH;
Â  Â  Â  Â  // Check if target is in front or behind
Â  Â  Â  Â  let dirX = x - halfW;
Â  Â  Â  Â  let dirY = y - halfH;
Â  Â  Â  Â  if (vector.z > 1) {
Â  Â  Â  Â  Â  // Behind camera â†’ flip direction
Â  Â  Â  Â  Â  dirX = -dirX;
Â  Â  Â  Â  Â  dirY = -dirY;
Â  Â  Â  Â  }
Â  Â  Â  Â  // On screen?
Â  Â  Â  Â  if (vector.z < 1 &&
Â  Â  Â  Â  Â  Â  x >= 0 && x <= window.innerWidth &&
Â  Â  Â  Â  Â  Â  y >= 0 && y <= window.innerHeight) {
Â  Â  Â  Â  Â  // On screen â†’ hide arrow
Â  Â  Â  Â  Â  arrow.style.display = "none";
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  // Off screen â†’ show arrow
Â  Â  Â  Â  Â  arrow.style.display = "block";
Â  Â  Â  Â  Â  const angle = Math.atan2(dirY, dirX);
Â  Â  Â  Â  Â  // Push arrow to screen edge
Â  Â  Â  Â  Â  const edgeBuffer = 40;
Â  Â  Â  Â  Â  const slope = dirY / dirX;
Â  Â  Â  Â  Â  if (Math.abs(dirX) > Math.abs(dirY)) {
Â  Â  Â  Â  Â  Â  // hits left/right border
Â  Â  Â  Â  Â  Â  x = dirX > 0 ? window.innerWidth - edgeBuffer : edgeBuffer;
Â  Â  Â  Â  Â  Â  y = halfH + slope * (x - halfW);
Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  // hits top/bottom border
Â  Â  Â  Â  Â  Â  y = dirY > 0 ? window.innerHeight - edgeBuffer : edgeBuffer;
Â  Â  Â  Â  Â  Â  x = halfW + (y - halfH) / slope;
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  arrow.style.left = `${x - 12}px`;
Â  Â  Â  Â  Â  arrow.style.top = `${y - 12}px`;
Â  Â  Â  Â  Â  arrow.style.transform = `rotate(${angle}rad)`;
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  Â  renderer.render(scene, camera);
Â  Â  }
Â  Â  // Main execution
Â  Â  loadModels().then(() => {
Â  Â  Â  Â  scene.add(spaceship);
Â  Â  Â  Â  alignShipToVelocity(1.0);
Â  Â  Â  Â  animate();
Â  Â  Â  Â  setTimeout(enemyShoot, 1200);
Â  Â  }).catch(error => {
Â  Â  Â  Â  console.error('Error loading models:', error);
Â  Â  });

Â  Â  // Reset
Â  Â  function reset(){
Â  Â  Â  playerHP=20; enemyHP=25; updateHP();
Â  Â  Â  winDiv.style.display='none'; loseDiv.style.display='none';
Â  Â  Â  gameOver=false;
Â  Â  Â  spaceshipPos = randomUnit().multiplyScalar(sphereRadius*0.4);
Â  Â  Â  spaceshipVel = randomUnit().multiplyScalar(speed);
Â  Â  Â  desiredVel = spaceshipVel.clone();
Â  Â  Â  if(spaceship) spaceship.position.copy(spaceshipPos);
Â  Â  Â  bullets.forEach(b=>scene.remove(b.mesh)); bullets.length=0;
Â  Â  Â  enemyBullets.forEach(b=>scene.remove(b.mesh)); enemyBullets.length=0;
Â  Â  Â  missiles.forEach(m=>scene.remove(m.mesh)); missiles.length=0;
Â  Â  Â  trailParticles.forEach(p=>scene.remove(p.mesh)); trailParticles.length=0;
Â  Â  }
Â  Â  // Reset button
Â  Â  document.getElementById('resetBtn').addEventListener('click', reset);
Â  Â  document.getElementById('shootBtn').addEventListener('click', shoot);
Â  Â  document.getElementById('rollLeft').addEventListener('mousedown',()=>pressKey('KeyA'));
Â  Â  document.getElementById('rollLeft').addEventListener('mouseup',()=>releaseKey('KeyA'));
Â  Â  document.getElementById('rollRight').addEventListener('mousedown',()=>pressKey('KeyD'));
Â  Â  document.getElementById('rollRight').addEventListener('mouseup',()=>releaseKey('KeyD'));
Â  Â  // Resize
Â  Â  window.addEventListener('resize',()=>{
Â  Â  Â  camera.aspect = window.innerWidth/window.innerHeight;
Â  Â  Â  camera.updateProjectionMatrix();
Â  Â  Â  renderer.setSize(window.innerWidth, window.innerHeight);
Â  Â  });
Â  </script>
</body>
</html>
